"""
Application metrics collection and monitoring infrastructure.

This module provides Prometheus-based metrics collection for the multi-agent
Faculty Research Opportunity Notifier system, including:
- HTTP request metrics
- Agent execution metrics
- System health metrics
- External service monitoring
"""

from prometheus_client import Counter, Histogram, Gauge, Info
from typing import Dict, Any
import time
import functools
import logging

logger = logging.getLogger(__name__)

# ============================================================================
# HTTP and API Metrics
# ============================================================================

# HTTP request metrics
http_requests_total = Counter(
    'http_requests_total',
    'Total HTTP requests processed',
    ['method', 'endpoint', 'status']
)

http_request_duration_seconds = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration in seconds',
    ['method', 'endpoint']
)

# ============================================================================
# Agent-Specific Metrics
# ============================================================================

# Agent execution metrics
agent_executions_total = Counter(
    'agent_executions_total',
    'Total agent executions',
    ['agent_name', 'status']
)

agent_execution_duration_seconds = Histogram(
    'agent_execution_duration_seconds',
    'Agent execution duration in seconds',
    ['agent_name']
)

agent_queue_size = Gauge(
    'agent_queue_size',
    'Number of tasks in agent queue',
    ['agent_name']
)

# A2A communication metrics (for future Phase 5)
a2a_messages_total = Counter(
    'a2a_messages_total',
    'Total agent-to-agent messages',
    ['sender_agent', 'receiver_agent', 'message_type']
)

a2a_message_processing_duration_seconds = Histogram(
    'a2a_message_processing_duration_seconds',
    'A2A message processing duration in seconds',
    ['sender_agent', 'receiver_agent']
)

# ============================================================================
# Data Processing Metrics
# ============================================================================

# Data ingestion metrics
funding_opportunities_scraped_total = Counter(
    'funding_opportunities_scraped_total',
    'Total funding opportunities scraped',
    ['source']
)

faculty_profiles_discovered_total = Counter(
    'faculty_profiles_discovered_total',
    'Total faculty profiles discovered',
    ['source']
)

matches_generated_total = Counter(
    'matches_generated_total',
    'Total matches generated by matcher agent',
    ['match_score_range']
)

# ============================================================================
# External Service Metrics
# ============================================================================

# External API call metrics
external_api_calls_total = Counter(
    'external_api_calls_total',
    'Total external API calls',
    ['service', 'endpoint', 'status']
)

external_api_duration_seconds = Histogram(
    'external_api_duration_seconds',
    'External API call duration in seconds',
    ['service', 'endpoint']
)

external_api_rate_limit_hits_total = Counter(
    'external_api_rate_limit_hits_total',
    'Total rate limit hits for external APIs',
    ['service']
)

# ============================================================================
# System Health Metrics
# ============================================================================

# System health gauges
system_memory_usage_bytes = Gauge(
    'system_memory_usage_bytes',
    'System memory usage in bytes'
)

system_cpu_usage_percent = Gauge(
    'system_cpu_usage_percent',
    'System CPU usage percentage'
)

active_connections = Gauge(
    'active_connections',
    'Number of active database connections'
)

# ============================================================================
# Phase 4 Dashboard and Analytics Metrics
# ============================================================================

# Dashboard usage metrics
dashboard_page_views_total = Counter(
    'dashboard_page_views_total',
    'Total dashboard page views',
    ['page', 'user_agent']
)

dashboard_auto_refresh_total = Counter(
    'dashboard_auto_refresh_total',
    'Total dashboard auto-refresh events'
)

dashboard_user_actions_total = Counter(
    'dashboard_user_actions_total',
    'Total user actions on dashboard',
    ['action']
)

dashboard_load_time_seconds = Histogram(
    'dashboard_load_time_seconds',
    'Dashboard page load time in seconds',
    ['page']
)

# Analytics cache metrics
analytics_cache_hits_total = Counter(
    'analytics_cache_hits_total',
    'Total analytics cache hits'
)

analytics_cache_misses_total = Counter(
    'analytics_cache_misses_total',
    'Total analytics cache misses'
)

analytics_cache_age_seconds = Gauge(
    'analytics_cache_age_seconds',
    'Age of analytics cache in seconds'
)

analytics_processing_duration_seconds = Histogram(
    'analytics_processing_duration_seconds',
    'Analytics data processing duration in seconds',
    ['data_type']
)

analytics_data_freshness_hours = Gauge(
    'analytics_data_freshness_hours',
    'Age of analytics data in hours'
)

# Export system metrics
export_requests_total = Counter(
    'export_requests_total',
    'Total export requests',
    ['export_type', 'format', 'status']
)

export_processing_duration_seconds = Histogram(
    'export_processing_duration_seconds',
    'Export processing duration in seconds',
    ['export_type', 'format']
)

export_file_size_bytes = Histogram(
    'export_file_size_bytes',
    'Size of exported files in bytes',
    ['export_type', 'format']
)

export_items_processed_total = Counter(
    'export_items_processed_total',
    'Total items processed during export',
    ['export_type']
)

# Configuration management metrics
config_load_operations_total = Counter(
    'config_load_operations_total',
    'Total configuration load operations',
    ['config_type', 'status']
)

config_validation_errors_total = Counter(
    'config_validation_errors_total',
    'Total configuration validation errors',
    ['config_type', 'error_type']
)

config_load_duration_seconds = Histogram(
    'config_load_duration_seconds',
    'Configuration load duration in seconds',
    ['config_type']
)

config_cache_age_seconds = Gauge(
    'config_cache_age_seconds',
    'Age of configuration cache in seconds',
    ['config_type']
)

# Application info
application_info = Info(
    'application_info',
    'Application information'
)

# Set application info
application_info.info({
    'version': '1.0.0',
    'name': 'Faculty Research Opportunity Notifier',
    'description': 'AI-driven multi-agent research funding opportunity system'
})

# ============================================================================
# Metric Helper Functions
# ============================================================================

def track_agent_execution(agent_name: str):
    """
    Decorator to track agent execution metrics.
    
    Args:
        agent_name: Name of the agent being tracked
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            status = 'success'
            
            try:
                result = await func(*args, **kwargs)
                return result
            except Exception as e:
                status = 'error'
                logger.error(f"Agent {agent_name} execution failed: {e}")
                raise
            finally:
                execution_time = time.time() - start_time
                agent_executions_total.labels(
                    agent_name=agent_name,
                    status=status
                ).inc()
                agent_execution_duration_seconds.labels(
                    agent_name=agent_name
                ).observe(execution_time)
                
        return wrapper
    return decorator

def track_external_api_call(service: str, endpoint: str):
    """
    Decorator to track external API call metrics.
    
    Args:
        service: Name of the external service
        endpoint: API endpoint being called
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            status = 'success'
            
            try:
                result = await func(*args, **kwargs)
                return result
            except Exception as e:
                status = 'error'
                logger.error(f"External API call to {service}/{endpoint} failed: {e}")
                raise
            finally:
                call_duration = time.time() - start_time
                external_api_calls_total.labels(
                    service=service,
                    endpoint=endpoint,
                    status=status
                ).inc()
                external_api_duration_seconds.labels(
                    service=service,
                    endpoint=endpoint
                ).observe(call_duration)
                
        return wrapper
    return decorator

def update_system_metrics():
    """
    Update system health metrics.
    This function should be called periodically by a background task.
    """
    try:
        import psutil
        
        # Update memory usage
        memory_info = psutil.virtual_memory()
        system_memory_usage_bytes.set(memory_info.used)
        
        # Update CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        system_cpu_usage_percent.set(cpu_percent)
        
    except ImportError:
        logger.warning("psutil not available, system metrics not updated")
    except Exception as e:
        logger.error(f"Failed to update system metrics: {e}")

def record_funding_opportunity_scraped(source: str):
    """Record that a funding opportunity was scraped from a source."""
    funding_opportunities_scraped_total.labels(source=source).inc()

def record_faculty_profile_discovered(source: str):
    """Record that a faculty profile was discovered from a source."""
    faculty_profiles_discovered_total.labels(source=source).inc()

def record_match_generated(score: float):
    """Record that a match was generated with a given score."""
    if score >= 0.8:
        score_range = 'high'
    elif score >= 0.6:
        score_range = 'medium'
    else:
        score_range = 'low'
    
    matches_generated_total.labels(match_score_range=score_range).inc()

def record_rate_limit_hit(service: str):
    """Record that a rate limit was hit for an external service."""
    external_api_rate_limit_hits_total.labels(service=service).inc()

def update_agent_queue_size(agent_name: str, size: int):
    """Update the queue size for a specific agent."""
    agent_queue_size.labels(agent_name=agent_name).set(size)

def record_a2a_message(sender: str, receiver: str, message_type: str, processing_time: float = None):
    """
    Record an agent-to-agent message for Phase 5 A2A communication.
    
    Args:
        sender: Name of the sending agent
        receiver: Name of the receiving agent
        message_type: Type of message (e.g., 'trigger', 'data', 'response')
        processing_time: Optional processing time in seconds
    """
    a2a_messages_total.labels(
        sender_agent=sender,
        receiver_agent=receiver,
        message_type=message_type
    ).inc()
    
    if processing_time is not None:
        a2a_message_processing_duration_seconds.labels(
            sender_agent=sender,
            receiver_agent=receiver
        ).observe(processing_time)

# ============================================================================
# Phase 4 Metric Helper Functions
# ============================================================================

def record_dashboard_page_view(page: str, user_agent: str = 'unknown'):
    """Record a dashboard page view."""
    dashboard_page_views_total.labels(page=page, user_agent=user_agent).inc()

def record_dashboard_auto_refresh():
    """Record a dashboard auto-refresh event."""
    dashboard_auto_refresh_total.inc()

def record_dashboard_user_action(action: str):
    """Record a user action on the dashboard."""
    dashboard_user_actions_total.labels(action=action).inc()

def track_dashboard_load_time(page: str):
    """
    Decorator to track dashboard page load time.
    
    Args:
        page: Name of the dashboard page
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                return result
            finally:
                load_time = time.time() - start_time
                dashboard_load_time_seconds.labels(page=page).observe(load_time)
        return wrapper
    return decorator

def record_analytics_cache_hit():
    """Record an analytics cache hit."""
    analytics_cache_hits_total.inc()

def record_analytics_cache_miss():
    """Record an analytics cache miss."""
    analytics_cache_misses_total.inc()

def update_analytics_cache_age(age_seconds: float):
    """Update the age of the analytics cache."""
    analytics_cache_age_seconds.set(age_seconds)

def track_analytics_processing(data_type: str):
    """
    Decorator to track analytics processing duration.
    
    Args:
        data_type: Type of data being processed
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                return result
            finally:
                processing_time = time.time() - start_time
                analytics_processing_duration_seconds.labels(
                    data_type=data_type
                ).observe(processing_time)
        return wrapper
    return decorator

def update_analytics_data_freshness(hours: float):
    """Update the freshness of analytics data."""
    analytics_data_freshness_hours.set(hours)

def record_export_request(export_type: str, format_type: str, status: str):
    """Record an export request."""
    export_requests_total.labels(
        export_type=export_type,
        format=format_type,
        status=status
    ).inc()

def track_export_processing(export_type: str, format_type: str):
    """
    Decorator to track export processing duration.
    
    Args:
        export_type: Type of export (e.g., 'proposal', 'collaboration')
        format_type: Export format (e.g., 'json', 'csv', 'html')
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                return result
            finally:
                processing_time = time.time() - start_time
                export_processing_duration_seconds.labels(
                    export_type=export_type,
                    format=format_type
                ).observe(processing_time)
        return wrapper
    return decorator

def record_export_file_size(export_type: str, format_type: str, size_bytes: int):
    """Record the size of an exported file."""
    export_file_size_bytes.labels(
        export_type=export_type,
        format=format_type
    ).observe(size_bytes)

def record_export_items_processed(export_type: str, count: int):
    """Record the number of items processed during export."""
    export_items_processed_total.labels(export_type=export_type).inc(count)

def record_config_load_operation(config_type: str, status: str):
    """Record a configuration load operation."""
    config_load_operations_total.labels(
        config_type=config_type,
        status=status
    ).inc()

def record_config_validation_error(config_type: str, error_type: str):
    """Record a configuration validation error."""
    config_validation_errors_total.labels(
        config_type=config_type,
        error_type=error_type
    ).inc()

def track_config_load_time(config_type: str):
    """
    Decorator to track configuration load duration.
    
    Args:
        config_type: Type of configuration being loaded
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                return result
            finally:
                load_time = time.time() - start_time
                config_load_duration_seconds.labels(
                    config_type=config_type
                ).observe(load_time)
        return wrapper
    return decorator

def update_config_cache_age(config_type: str, age_seconds: float):
    """Update the age of a configuration cache."""
    config_cache_age_seconds.labels(config_type=config_type).set(age_seconds)